"""AI Finish Task tool - finalizes session and updates context files."""

from __future__ import annotations

import argparse
import re
import shutil
import sys
from pathlib import Path

from scripts.ai_tools.utils import (
    format_timestamp,
    get_archive_dir,
    get_current_session,
    get_session_files,
    get_sessions_dir,
    print_error,
    print_header,
    print_warning,
    read_context_file,
    write_context_file,
)


def extract_files_changed(execution_content: str) -> list[str]:
    """Extract files changed from execution log.

    Args:
        execution_content: Content of EXECUTION file

    Returns:
        List of file paths mentioned
    """
    files = []

    # Look for common patterns like file paths
    patterns = [
        r"(?:Created|Modified|Updated|Added)\s+([a-zA-Z0-9_./\-]+\.(?:py|md|txt|yml|yaml|toml|json))",
        r"`([a-zA-Z0-9_./\-]+\.(?:py|md|txt|yml|yaml|toml|json))`",
        r"([a-zA-Z0-9_./\-]+\.py)",
    ]

    for pattern in patterns:
        matches = re.findall(pattern, execution_content, re.IGNORECASE)
        files.extend(matches)

    # Remove duplicates and sort
    files = sorted(set(files))

    return files


def extract_decisions(execution_content: str) -> list[str]:
    """Extract decisions from execution log.

    Args:
        execution_content: Content of EXECUTION file

    Returns:
        List of decisions
    """
    decisions = []

    # Look for decision-related log entries
    pattern = r"\[.*?\]\s+.*?(?:decision|decided|chose):\s*(.+?)(?:\n|$)"
    matches = re.findall(pattern, execution_content, re.IGNORECASE)

    decisions.extend(matches)

    return decisions


def extract_task_name_from_filename(plan_file_path: Path) -> str:
    """Extract task name from PLAN filename as fallback.

    Args:
        plan_file_path: Path to PLAN file

    Returns:
        Task name extracted from filename slug
    """
    # Filename format: YYYYMMDDHHMMSS-PLAN-slug.md
    filename = plan_file_path.name
    parts = filename.replace(".md", "").split("-", 2)

    if len(parts) >= 3:
        # Extract slug (third part), convert hyphens to spaces, title case
        slug = parts[2]
        task_name = slug.replace("-", " ").title()
        return task_name

    return "Untitled Task"


def check_plan_completion(plan_content: str) -> tuple[bool, int, int]:
    """Check if plan is complete.

    Args:
        plan_content: Content of PLAN file

    Returns:
        Tuple of (is_complete, checked_count, total_count)
    """
    lines = plan_content.split("\n")
    total = 0
    checked = 0

    for line in lines:
        match = re.match(r"^\s*-\s*\[([ x])\]", line)
        if match:
            total += 1
            if match.group(1) == "x":
                checked += 1

    is_complete = total > 0 and checked == total

    return (is_complete, checked, total)


def check_make_check_ran(execution_content: str) -> bool:
    """Check if make check was run in execution log.

    Args:
        execution_content: Content of EXECUTION file

    Returns:
        True if make check was mentioned
    """
    return bool(re.search(r"make\s+check", execution_content, re.IGNORECASE))


def verify_plan_execution(plan_content: str, execution_content: str) -> list[str]:
    """Verify that checked plan items are mentioned in execution log.

    Args:
        plan_content: Content of PLAN file
        execution_content: Content of EXECUTION file

    Returns:
        List of checked plan items that are not mentioned in execution
    """
    lines = plan_content.split("\n")
    unverified_items = []

    for line in lines:
        # Check for checked checkboxes
        match = re.match(r"^\s*-\s*\[x\]\s*(.+)$", line, re.IGNORECASE)
        if match:
            item_text = match.group(1).strip()

            # Check if item text (or key parts of it) appear in execution log
            # Extract key terms (words longer than 3 chars) from item
            key_terms = [
                word
                for word in re.findall(r"\b\w+\b", item_text)
                if len(word) > 3
            ]

            # If at least 2 key terms are mentioned, consider it verified
            mentioned_count = sum(
                1
                for term in key_terms
                if re.search(
                    r"\b" + re.escape(term) + r"\b", execution_content, re.IGNORECASE
                )
            )

            # If less than half of key terms mentioned, mark as unverified
            if key_terms and mentioned_count < len(key_terms) / 2:
                unverified_items.append(item_text)

    return unverified_items


def update_last_session_summary(
    session_id: str,
    task_name: str,
    summary_content: str,
) -> None:
    """Update LAST_SESSION_SUMMARY.md with this session.

    Args:
        session_id: Session ID
        task_name: Task name
        summary_content: Content of SUMMARY file
    """
    timestamp = format_timestamp()

    # Extract key info from summary
    status = "âœ… Completed"

    new_summary = f"""# Last Session Summary

> **Auto-updated by AI agents**: This file contains a summary of the most recent AI session

## Session Information

**Session ID**: {session_id}
**Task**: {task_name}
**Date**: {timestamp}
**Status**: {status}

{summary_content}

---

**This file is automatically updated by the last AI agent to complete a task.**
**Next AI agent: Read this file first to understand recent work!**

**Last Updated**: {timestamp}
"""

    write_context_file("LAST_SESSION_SUMMARY.md", new_summary)


def remove_task_from_active(task_name: str, session_id: str) -> None:
    """Remove task from ACTIVE_TASKS.md In Progress section.

    Args:
        task_name: Task name
        session_id: Session ID
    """
    active_tasks = read_context_file("ACTIVE_TASKS.md")

    if not active_tasks:
        return

    lines = active_tasks.split("\n")

    # Find and remove the task line
    new_lines = []
    for line in lines:
        # Skip lines that contain this session ID or task name
        if session_id in line or task_name in line:
            continue
        new_lines.append(line)

    write_context_file("ACTIVE_TASKS.md", "\n".join(new_lines))


def archive_old_sessions() -> int:
    """Archive sessions older than the 5 most recent.

    Returns:
        Number of sessions archived
    """
    sessions_dir = get_sessions_dir()
    archive_dir = get_archive_dir()

    if not sessions_dir.exists():
        return 0

    # Get all summary files
    summary_files = sorted(sessions_dir.glob("*-SUMMARY-*.md"), reverse=True)

    # Keep first 5, archive the rest
    to_archive = summary_files[5:]

    if not to_archive:
        return 0

    # Create archive directory
    archive_dir.mkdir(parents=True, exist_ok=True)

    archived_count = 0
    for summary_file in to_archive:
        # Get session ID from filename
        session_id = summary_file.name[:14]

        # Find all files for this session
        session_files = list(sessions_dir.glob(f"{session_id}-*"))

        # Move all to archive
        for file in session_files:
            dest = archive_dir / file.name
            shutil.move(str(file), str(dest))
            archived_count += 1

    return archived_count // 3  # Divide by 3 since each session has 3 files


def finish_task(
    summary: str | None = None,
    session_id: str | None = None,
    yes: bool = True,
) -> None:
    """Finalize task and update all context files.

    Args:
        summary: Brief summary (default: prompt user)
        session_id: Session ID (default: most recent)
        yes: Skip interactive prompts (default: True)
    """
    # Get current session if not specified
    if session_id is None:
        session_id = get_current_session()

    if session_id is None:
        print_error("No active session found")
        print("Run 'ai-start-task' first to create a session")
        sys.exit(1)

    # Get session files
    session_files = get_session_files(session_id)
    plan_file = session_files["plan"]
    summary_file = session_files["summary"]
    execution_file = session_files["execution"]

    if not all([plan_file, summary_file, execution_file]):
        print_error(f"Session files not found for session {session_id}")
        sys.exit(1)

    # Type narrowing: we know these are Path objects after the check
    assert plan_file is not None
    assert summary_file is not None
    assert execution_file is not None

    # Read files
    plan_content = plan_file.read_text()
    summary_file.read_text()
    execution_content = execution_file.read_text()

    # Extract task name from file header
    task_name_match = re.search(r"# Task (?:Plan|Summary): (.+)", plan_content)

    if task_name_match:
        task_name = task_name_match.group(1)
    else:
        # Fallback: extract from filename instead of using "Unknown Task"
        task_name = extract_task_name_from_filename(plan_file)

    print_header(f"âœ… Finishing Task: {task_name}")

    # Check plan completion
    is_complete, checked, total = check_plan_completion(plan_content)
    if not is_complete and total > 0:
        print_warning(f"Plan is not 100% complete ({checked}/{total} items checked)")
        if not yes:
            response = input("Continue anyway? [y/N]: ").strip().lower()
            if response != "y":
                print("Task not finished. Complete the plan first.")
                sys.exit(0)

    # Check if make check was run
    if not check_make_check_ran(execution_content):
        print_warning("'make check' was not logged in execution")
        if not yes:
            response = input("Continue anyway? [y/N]: ").strip().lower()
            if response != "y":
                print("Task not finished. Run 'make check' first.")
                sys.exit(0)

    # Verify plan execution
    unverified_items = verify_plan_execution(plan_content, execution_content)
    if unverified_items:
        print_warning(
            f"Some checked plan items may not have been executed ({len(unverified_items)} items)"
        )
        print("\nâš ï¸  Plan items not clearly mentioned in execution log:")
        for item in unverified_items[:5]:  # Show first 5
            print(f"  â€¢ {item}")
        if len(unverified_items) > 5:
            print(f"  ... and {len(unverified_items) - 5} more")
        print(
            "\nTip: Use 'ai-log' with specific details (file names, test names) "
            "for better verification.\n"
        )

    # Get summary if not provided
    if summary is None:
        print("\nðŸ“ Enter task summary:")
        summary = input("> ").strip()
        if not summary:
            summary = "Task completed"

    # Extract information from execution log
    files_changed = extract_files_changed(execution_content)
    decisions_made = extract_decisions(execution_content)

    # Update SUMMARY file
    timestamp = format_timestamp()
    updated_summary = f"""# Task Summary: {task_name}

**Session ID**: {session_id}
**Created**: {timestamp}
**Status**: âœ… Completed

---

## What Was Done

{summary}

---

## Decisions Made

"""

    if decisions_made:
        for decision in decisions_made:
            updated_summary += f"- {decision}\n"
    else:
        updated_summary += "- No major decisions recorded\n"

    updated_summary += "\n---\n\n## Files Changed\n\n"

    if files_changed:
        for file in files_changed:
            updated_summary += f"- `{file}`\n"
    else:
        updated_summary += "- No files tracked\n"

    updated_summary += "\n---\n\n## Notes\n\n[Session complete]\n"

    summary_file.write_text(updated_summary)

    # Update LAST_SESSION_SUMMARY.md
    update_last_session_summary(session_id, task_name, updated_summary)

    # Remove from ACTIVE_TASKS.md
    remove_task_from_active(task_name, session_id)

    # Archive old sessions
    archived_count = archive_old_sessions()

    # Display completion message
    print("\nðŸ“ Summary:")
    print(f"{summary}")
    print()

    if files_changed:
        print("ðŸ“ Files Changed:")
        for file in files_changed[:10]:  # Show first 10
            print(f"  â€¢ {file}")
        if len(files_changed) > 10:
            print(f"  ... and {len(files_changed) - 10} more")
        print()

    print("ðŸ“š Context Updated:")
    print("  âœ… LAST_SESSION_SUMMARY.md")
    print("  âœ… ACTIVE_TASKS.md (task marked complete)")
    if archived_count > 0:
        print(f"  âœ… Archived {archived_count} old sessions")
    print()

    print("âœ¨ Ready for next task! Run ai-start-task to begin.")
    print()


def main() -> None:
    """Main entry point for ai-finish-task command."""
    parser = argparse.ArgumentParser(
        description="Finalize task and update context files",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  ai-finish-task
  ai-finish-task --summary="Implemented email validation with tests"
        """,
    )
    parser.add_argument(
        "--summary",
        help="Brief task summary",
    )
    parser.add_argument(
        "--session-id",
        help="Specific session ID (default: most recent session)",
    )
    parser.add_argument(
        "--yes",
        "-y",
        action="store_true",
        default=True,
        help="Skip interactive prompts (default: True)",
    )
    parser.add_argument(
        "--interactive",
        "-i",
        action="store_true",
        help="Enable interactive prompts (overrides --yes default)",
    )

    args = parser.parse_args()

    # --interactive overrides the default --yes behavior
    yes_mode = not args.interactive if args.interactive else args.yes

    finish_task(
        summary=args.summary,
        session_id=args.session_id,
        yes=yes_mode,
    )


if __name__ == "__main__":
    main()
